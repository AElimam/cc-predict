"""
    Cloud Computing Predict Pipeline Automated Testing.
    Author: Explore Data Science Academy.

    Description:

    This script is used for the automated marking of student submissions for 
    the Cloud Computing Digital Skill Predict. For a full description of its 
    use, please refer to the README.md collocated with this file.  
"""  

# Library dependencies
# Script interaction 
import os
import argparse
import csv
from time import sleep
# Webpage
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.chrome.options import Options
from webdriver_manager.chrome import ChromeDriverManager
# Gateway API
import requests
import json
from datetime import datetime, timedelta
# Gmail API
import pickle
import os.path
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

# --- CONFIGS ---
# Selenium
WEBSITE_TIMEOUT = 10

# Section marks:
# Please note that the default values assigned need to be calibrated
# according to facilitation's needs.
WEBSITE_MARK = 5
DYNAMODB_MARK = 10
SES_MARK = 10
MAIL_LOGIC_MARK = 15

# --- HELPER FUNCTIONS --- 

# GMAIL-BASED MARKING
def get_gmail_credentials(cred_path='assets/credentials.json'):
    """Load credentials for the Gmail API service 

    Args:
        cred_path (str, optional): Path to your 'credentials.json' file 
                                   generated by the Google API console. 
                                   Defaults to 'credentials.json'.

    Returns:
        creds: The loaded credentials object used for API authorization
    """

    # Define the actions which the API can perform
    # Enable Readonly actions 
    SCOPES = ['https://www.googleapis.com/auth/gmail.readonly']

    # Attempt to retrieve credentials
    creds = None
    if os.path.exists('assets/token.pickle'):
        with open('assets/token.pickle', 'rb') as token:
            creds = pickle.load(token)

    # Credentials not found - sign in to create new token.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else: 
            flow = InstalledAppFlow.from_client_secrets_file(cred_path, SCOPES)
            creds = flow.run_local_server(port=0)
        with open('assets/token.pickle', 'wb') as token:
            pickle.dump(creds, token)
            
    return creds

def get_message_id(creds, search_criteria='', max_results=1):
    """Fetch a message ID matching a search criteria via the Gmail API

    Args:
        creds (API object): Gmail API credentials
        search_criteria (str, optional): Search string to filter listed messages. 
                                         Defaults to ''.
        max_results (int, optional): Number of results to return. Defaults to 1.

    Returns:
        String: A message ID matching the search criteria provided.  
    """

    service = build('gmail', 'v1', credentials=creds)
    result = service.users().messages().list(userId='me',
                                              q=search_criteria, 
                                              maxResults=max_results).execute()
    mesg_id = result.get('messages')[0]['id']
    return mesg_id

def get_message_contents(creds, mesg_id):
    """Retrieve the contents of an email via the Gmail API

    Args:
        creds (API object): Gmail API credentials
        mesg_id (str): UUID for the email message

    Returns:
        Dict: Contents of the message corresponding to mesg_id
    """

    service = build('gmail', 'v1', credentials=creds)
    results = service.users().messages().get(userId='me',
                                             id=mesg_id).execute()
    return results

def mark_email(creds, student_name, search_phrase=''):
    """Mark a student's system-generated email using the Gmail API  

    Args:
        creds (API object): Gmail API credentials
        student_name (str): {Name_Surname} of student being marked
        search_phrase (str): [Optional] Text extract to find in email
                                to validate operation.

    Returns:
        int: Assigned student mark
    """

    if search_phrase == '':
        search_phrase = student_name

    try:
        search_string = f'subject:Data Science Portfolio Website - Hello {student_name}'
        mesg_id = get_message_id(creds=creds,
                                search_criteria=search_string)
        mesg_contents = get_message_contents(creds=creds, 
                                             mesg_id=mesg_id)
        if mesg_contents['snippet'].find(search_phrase) != -1:
            # Email logic working correctly - assign full marks
            return MAIL_LOGIC_MARK
        else: 
            # Email delivered but logic not working - assign partial marks
            return MAIL_LOGIC_MARK/2
    except: 
        print ("Student mail not found, assigning mark of 0...")
        return 0

# WEBSITE MARKING
def mark_website(url):
    """Mark a student's portfolio website using Selenium.  

    Args:
        url (str): URL of the website to test.

    Returns:
        int: Assigned student mark.
    """

    # Load chromedriver. We use headless mode to 
    # improve performance and cross-OS support. 
    chrome_options = Options()
    chrome_options.add_argument("--headless")
    driver = webdriver.Chrome(executable_path=os.path.join(os.getcwd(),
                              'assets/chromedriver'),
                              options=chrome_options)
    driver.set_page_load_timeout(WEBSITE_TIMEOUT)

    # We try to find the unique Id tag for the portfolio website form.
    try:
        driver.get(url)
        a = driver.find_element_by_xpath("//form[@id='contactFormDS']")
        result = WEBSITE_MARK
        driver.close()
    except Exception as e:
        driver.close()
        print (f'The student website could not be found with URL: {url}')
        result = 0
    return result

# API-BASED MARKING
def get_gateway_api_response(api_url, student_name):
    """Call a student's API Gateway and retrieve their lambda response.

    Args:
        api_url (str): Student's AWS API Gateway endpoint.
        student_name (str): {Name_Surname} of student.

    Returns:
        dict: API Gateway POST request response. 
    """
    
    response = []
    init_req_time = None

    # Configure request payload
    request_payload = {
        'name': f'{student_name}',
        'phone': '0123456789',
        'email': 'edsa.predicts@explore-ai.net',
        'message': "Trial message"
    }
    # Convert dict for POST request
    request_payload = json.dumps(request_payload)
    try:
        # Capture time of POST Request.
        # Used downstream to verify the API is giving dynamic responses
        init_req_time = datetime.utcnow()
        # Send POST request to API
        response = requests.post(url=api_url, data=request_payload)
        # De-stringify the received JSON into a Python dictionary
        response = json.loads(response.content)
    except:
        print (f"An error occurred - please review student API url manually: {api_url}")
        response = {'name': f'{student_name}', 
                    'API URL' : api_url,
                    'outcome':'An error occurred calling the API gateway. Please mark manually.'}

    return response, init_req_time    

def is_recent_response(api_resp_time, req_time):
    """Convert and compare input timestamps to ensure that they are chronologically correct.

    If the API response from a student's lambda is authentic, we expect to see 
    api_resp_time > (later than) req time. 

    Args:
        api_resp_time (str): API response timestamp metadata. e.g. 
                             'Wed, 27 April 1994 13:00:00'.
        req_time (datetime): Datetime object (UCT) representing when the API call was made.

    Returns:
        boolean: Whether or not the timestamps are chronologically correct. 
    """

    # Convert timestamp string to timestamp object
    api_resp_time = datetime.strptime(api_resp_time, '%a, %d %b %Y %H:%M:%S %Z')
    # Determine if the API responded after the API call was made. 
    is_recent = api_resp_time > req_time
    return is_recent

def mark_dynamodb(api_response, request_timestamp):
    """Mark the functioning of a student's DynamoDB insertion code

    Args:
        api_response (dict): POST response generated by the student's lambda function.
        request_timestamp (str): response timestamp metadata. e.g. 
                                    'Wed, 27 April 1994 13:00:00' 

    Returns:
        int: Assigned student mark
    """

    try:
        # Check insertion status
        if api_response['DB_response']['ResponseMetadata']['HTTPStatusCode'] != 200:
            return 0
        # Check for dynamic response 
        db_date = api_response['DB_response']['ResponseMetadata']['HTTPHeaders']['date']
        if not is_recent_response(db_date, request_timestamp):
            return 0 
        # Insertion successful + dynamic --> assign full marks
        return DYNAMODB_MARK
    except: 
        print("Received malformed response - assigning mark of 0")
        return 0

def mark_ses(api_response, request_timestamp):
    """Mark the functioning of a student's SES message code

    Args:
        api_response (dict): POST response generated by the student's lambda function.
        request_timestamp (str): response timestamp metadata. e.g. 
                                    'Wed, 27 April 1994 13:00:00' 

    Returns:
        int: Assigned student mark
    """

    try:
        # Check send status
        if api_response['SES_response']['ResponseMetadata']['HTTPStatusCode'] != 200:
            return 0
        # Check for dynamic response 
        email_date = api_response['SES_response']['ResponseMetadata']['HTTPHeaders']['date']
        if not is_recent_response(email_date, request_timestamp):
            return 0 
        # Insertion successful + dynamic --> assign full marks
        return SES_MARK
    except:
        print("Received malformed response - assigning mark of 0")
        return 0

# --- MAIN MARKING LOOP ---

def mark_student_predicts(student_detail_file, api_credentials):
    """Main method used to mark a given student's predict pipeline.

    Args:
        student_detail_file (str): Path to a .csv file containing student predict details.

    Returns:
        list[dict]: Student results - a list of student mark dictionaries.
        list[dict]: Student API responses - a list of student API response objects.
    """

    # Input validation 
    assert os.path.exists(student_detail_file)

    # Marking artefacts
    student_results = []
    student_api_responses = []

    # Setup credentials for marking
    creds = get_gmail_credentials(api_credentials)

    # Load student details
    with open(student_detail_file, 'r') as f:
        csvFile = csv.DictReader(f)
        # Iterate over each student submission
        for submission in csvFile:
            # Initialise marking data for student
            mark_dict = {}
            resp = {}
            student_name = f"{submission['Name']}_{submission['Surname']}"
            mark_dict['Name'] = student_name
            print ('-'*15)
            print (f"Commencing marking for student: {student_name}")
            # Assign website mark
            print ("Marking website component...")
            mark_dict['Website'] = mark_website(url=submission['Website_URL'])
            print (f"Scored {mark_dict['Website']}/{WEBSITE_MARK}")
            # Mark API Component
            print ("Gathering API Response...")
            resp, resp_time = get_gateway_api_response(submission['Gateway_URL'],
                                                       student_name)
            # Assign DynamoDB mark
            print ("Marking DynamoDB component...")
            mark_dict['DB'] = mark_dynamodb(resp, resp_time)
            print (f"Scored {mark_dict['DB']}/{DYNAMODB_MARK}")
            # Assign SES mark
            print ("Marking SES component...")
            mark_dict['SES'] = mark_ses(resp, resp_time)
            print (f"Scored {mark_dict['SES']}/{SES_MARK}")
            # Mark Email component
            print ("Marking Email component...")
            sleep (1)
            mark_dict['Email'] = mark_email(creds, student_name)
            print (f"Scored {mark_dict['Email']}/{MAIL_LOGIC_MARK}")
            print ("Student marking completed.")
            print ("")
            student_results.append(mark_dict)
            student_api_responses.append(resp)

    return student_results, student_api_responses
    

def write_student_results(target_file,results):
    """Writes a collection of student result dictionaries to a .csv file 

    Args:
        target_file (str): filename and path of .csv filename to save.
        results (list[dict]): list of student mark dictionaries.
    """
    
    fieldnames = ['Name', 'Website', 'DB', 'SES', 'Email']

    print ("Writing student results to file...")
    with open(target_file, 'w') as csvFile:
        writer = csv.DictWriter(csvFile,fieldnames)
        writer.writeheader()
        for entry in results:
            writer.writerow(entry)
    print ("Write complete.")
    

def write_student_api_responses(api_responses):
    """Writes a collection of student API responses to a log .txt file. 

    Args:
        api_responses (list[dict]): list of student API response objects.
    """

    print ("Saving response objects to log...") 
    with open('Student_API_logs.txt', 'w') as f:
        for response in api_responses:
            f.write("%s\n" % response)
    print ("Write complete.")

if __name__ == '__main__':

    flags = argparse.ArgumentParser(description="""
                Automate the Cloud Computing Predict Pipeline Marking""",
                formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    flags.add_argument('submission_file',
                        default=None,
                        help="""
                        Path to the target input file containing team names and
                        URLs.
                        """)
    
    flags.add_argument('--credentials_path',
                    default='assets/credentials.json',
                    type=str,
                    help="""
                    Path to a 'credentials.json file for authenticating with 
                    the Gmail API.
                    """)

    flags.add_argument('--output_file',
                        default='CC_Marking_Results.csv',
                        help="""
                        Name of output file.
                        """)

    FLAGS = flags.parse_args()



    student_resp, api_resp = mark_student_predicts(FLAGS.submission_file, 
                                                   FLAGS.credentials_path)
    write_student_results(FLAGS.output_file,student_resp)
    write_student_api_responses(api_resp)

